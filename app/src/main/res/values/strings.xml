<resources>
    <string name="app_name">BoOks-hUb</string>
    <string name="title_activity_books_hub">BooksHub</string>

    <string name="navigation_drawer_open">Open navigation drawer</string>
    <string name="navigation_drawer_close">Close navigation drawer</string>

    <string name="action_settings">Settings</string>

    <string name="abc">This involves number of simple steps to create Fragments."\n"
First of all decide how many fragments you want to use in an activity."\n"
For example lets we want to use two fragments to handle landscape and portrait modes of the device."\n"
Next based on number of fragments, create classes which will extend the Fragment class."\n"
The Fragment class has above mentioned callback functions. You can override any of the functions based on your requirements."\n"
Corresponding to each fragment, you will need to create layout files in XML file."\n"
These files will have layout for the defined fragments."\n"
Finally modify activity file to define the actual logic of replacing fragments based on your requirement.</string>
    <string name="xyz"><b><u>onAttach(Activity)</u></b>."\n"
It is called only once when it is attached with activity."\n"
onCreate(Bundle)"\n"
It is used to initialize the fragment."\n"
<b><u>onCreateView</u></b>(LayoutInflater, ViewGroup, Bundle)"\n"
creates and returns view hierarchy."\n"
<b><u>onActivityCreated(Bundle)</u></b>"\n"
It is invoked after the completion of onCreate() method."\n"
<b><u>onViewStateRestored(Bundle)</u></b>"\n"
It provides information to the fragment that all the saved state of fragment view hierarchy has been restored."\n"
<b><u>onStart()</u></b>"\n"
It makes the fragment visible."\n"
<b><u>onResume()</u></b>"\n"
It makes the fragment interactive."\n"
<b><u>onPause()</u></b>"\n"
It is called when fragment is no longer interactive."\n"
<b><u>onStop()</u></b>"\n"
It is called when fragment is no longer visible."\n"
<b><u>onDestroyView()</u></b>"\n"
It allows the fragment to clean up resources."\n"
<b><u>onDestroy()</u></b>"\n"
It allows the fragment to do final clean up of fragment state."\n"
<b><u>onDetach()</u></b>"\n"
It is called immediately prior to the fragment no longer being associated with its activity.</string>
    <string name="thread">
        When an application is launched, the system creates a thread of execution for the application,called main."\n"
        This thread is very important because it is in charge of dispatching events to the appropriate user interface widgets, including drawing events."\n"
        It is also almost always the thread in which your application interacts with components from the Android UI toolkit (components from the android.widget and android.view packages)."\n"
        As such, the main thread is also sometimes called the UI thread."\n"
        However, under special circumstances, an apps main thread might not be its UI thread;"\n"
The system does not create a separate thread for each instance of a component. "\n"
        All components that run in the same process are instantiated in the UI thread, and system calls to each component are dispatched from that thread."\n"
        Consequently, methods that respond to system callbacks (such as onKeyDown() to report user actions or a lifecycle callback method) always run in the UI thread of the process."\n"
For instance, when the user touches a button on the screen, your apps UI thread dispatches the touch event to the widget, which in turn sets its pressed state and posts an invalidate request to the event queue."\n"
        The UI thread dequeues the request and notifies the widget that it should redraw itself.

    </string>
    <string name="sqlite">
        SQLite is a opensource SQL database that stores data to a text file on a device. Android comes in with built in SQLite database implementation."\n"

SQLite supports all the relational database features. In order to access this database, you dont need to establish any kind of connections for it like JDBC,ODBC e.t.c"\n"

<b>Database - Package</b>"\n"
The main package is android.database.sqlite that contains the classes to manage your own databases"\n"

<b>Database - Creation</b>"\n"
In order to create a database you just need to call this method openOrCreateDatabase with your database name and mode as a parameter. It returns an instance of SQLite database which you have to receive in your own object.Its syntax is given below"\n"

SQLiteDatabase mydatabase = openOrCreateDatabase("your database name",MODE_PRIVATE,null);"\n"

<b>Database - Insertion</b>"\n"
we can create table or insert data into table using execSQL method defined in SQLiteDatabase class. Its syntax is given below"\n"

mydatabase.execSQL("CREATE TABLE IF NOT EXISTS TutorialsPoint(Username VARCHAR,Password VARCHAR);");"\n"
mydatabase.execSQL("INSERT INTO TutorialsPoint VALUES('admin','admin');");"\n"

<b>Database - Fetching</b>"\n"
We can retrieve anything from database using an object of the Cursor class. We will call a method of this class called rawQuery and it will return a resultset with the cursor pointing to the table. We can move the cursor forward and retrieve the data."\n"

Cursor resultSet = mydatbase.rawQuery("Select * from TutorialsPoint",null);"\n"
resultSet.moveToFirst();"\n"
String username = resultSet.getString(0);"\n"
String password = resultSet.getString(1);"\n"

<b>Database - Helper class</b>"\n"
For managing all the operations related to the database , an helper class has been given and is called SQLiteOpenHelper. It automatically manages the creation and update of the database. Its syntax is given below"\n"

public class DBHelper extends SQLiteOpenHelper {"\n"
   public DBHelper(){"\n"
      super(context,DATABASE_NAME,null,1);"\n"
   }"\n"
   public void onCreate(SQLiteDatabase db) {}"\n"
   public void onUpgrade(SQLiteDatabase database, int oldVersion, int newVersion) {}"\n"
}

    </string>
    <string name="soft_stack">At the bottom of the layers is Linux - Linux 2.6 with approximately 115 patches."\n"
        This provides basic system functionality like process management, memory management, device management like camera, keypad, display etc."\n"
        Also, the kernel handles all the things that Linux is really good at, such as networking and a vast array of device drivers, which take the pain out of interfacing to peripheral hardware.</string>
    <string name="service1">Android service is a component that is used to perform operations on the background such as playing music, handle network transactions, interacting content providers etc."\n"
        It does not has any UI (user interface)."\n"
The service runs in the background indefinitely even if application is destroyed."\n"
Moreover, service can be bounded by a component to perform interactivity and inter process communication (IPC)."\n"
The android.app.Service is subclass of ContextWrapper class.</string>
    <string name="service2">"\n"
        Started Service:"\n"
A service is started when component (like activity) calls <b>startService()</b> method, now it runs in the background indefinitely."\n"
It is stopped by <b>stopService()</b> method. The service can stop itself by calling the stopSelf() method."\n"
        "\n"
Bound Service:"\n"
A service is bound when another component (e.g. client) calls <b>bindService()</b> method."\n"
The client can unbind the service by calling the <b>unbindService()</b> method."\n"
The service cannot be stopped until all clients unbind the service.</string>
    <string name="intent">An Android Intent is an abstract description of an operation to be performed."\n"
It can be used with startActivity to launch an Activity, broadcastIntent to send it to any interested BroadcastReceiver components, and startService(Intent) or bindService(Intent, ServiceConnection, int) to communicate with a background Service."\n"
The intent itself, an Intent object, is a passive data structure holding an abstract description of an operation to be performed.</string>
    <string name="intent2">For example:"\n"
// Explicit Intent by specifying its class name"\n"
Intent i = new Intent(FirstActivity.this, SecondActivity.class);"\n"
// Starts TargetActivity"\n"
startActivity(i);</string>
    <string name="intent3">For example:"\n"
Intent read1=new Intent();"\n"
read1.setAction(android.content.Intent.ACTION_VIEW);"\n"
read1.setData(ContactsContract.Contacts.CONTENT_URI);"\n"
startActivity(read1);</string>
    <string name="int_res">A string containing additional information about the kind of component that should handle the intent."\n"
        Any number of category descriptions can be placed in an intent, but most intents do not require a category."\n"
        Here are some common categories:"\n"
<b>CATEGORY_BROWSABLE:</b>"\n"
The target activity allows itself to be started by a web browser to display data referenced by a link, such as an image or an e-mail message."\n"
<b>CATEGORY_LAUNCHER:</b>"\n"
The activity is the initial activity of a task and is listed in the system application launcher.</string>
    <string name="and_java">package com.example.helloworld;"\n"
import android.os.Bundle;"\n"
import android.app.Activity;"\n"
import android.view.Menu;"\n"
import android.view.MenuItem;"\n"
import android.support.v4.app.NavUtils;"\n"
public class MainActivity extends Activity "\n"
        {"\n"
    @Override"\n"
    public void onCreate(Bundle savedInstanceState)"\n"
        {"\n"
        super.onCreate(savedInstanceState);"\n"
        setContentView(R.layout.activity_main);"\n"
    }"\n"
    @Override"\n"
    public boolean onCreateOptionsMenu(Menu menu)"\n"
        {"\n"
        getMenuInflater().inflate(R.menu.activity_main, menu);"\n"
        return true;"\n"
    }"\n"
}</string>
    <string name="and_res">There are many more items which you use to build a good Android application."\n"
Apart from coding for the application, you take care of various other resources like static content that your code uses, such as bitmaps, colors, layout definitions, user interface strings, animation instructions, and more."\n"
        "\n"
        Here is a brief summary of each resource type:"\n"
Animation Resources:"\n"
Define pre-determined animations."\n"
Tween animations are saved in res or anim and accessed from the R.anim class."\n"
Frame animations are saved in res or drawable and accessed from the R.drawable class."\n"
"\n"
Color State List Resource:"\n"
Define a color resources that changes based on the View state."\n"
Saved in res/color/ and accessed from the R.color class."\n"
"\n"
Drawable Resources:"\n"
Define various graphics with bitmaps or XML."\n"
Saved in res or drawable and accessed from the R.drawable class."\n"
"\n"
Layout Resource:"\n"
Define the layout for your application UI."\n"
Saved in res or layout  and accessed from the R.layout class."\n"
"\n"
Menu Resource:"\n"
Define the contents of your application menus."\n"
Saved in res or menu and accessed from the R.menu class."\n"
"\n"
String Resources:"\n"
Define strings, string arrays, and plurals (and include string formatting and styling)."\n"
Saved in res or values and accessed from the R.string, R.array, and R.plurals classes."\n"
"\n"
Style Resource:"\n"
Define the look and format for UI elements."\n"
Saved in res or values and accessed from the R.style class."\n"
"\n"
Font Resources:"\n"
Define font families and include custom fonts in XML."\n"
Saved in res or font and accessed from the R.font class.</string>
    <string name="ins_act">An Android activity is one screen of the Android apps user interface."\n"
In that way an Android activity is very similar to windows in a desktop application."\n"
An Android app may contain one or more activities, meaning one or more screens."\n"
The Android app starts by showing the main activity, and from there the app may make it possible to open additional activities."\n"
If you have worked with C, C++ or Java programming language then you must have seen that your program starts from main() function."\n"
Very similar way, Android system initiates its program with in an Activity starting with a call on onCreate() callback method."\n"
There is a sequence of callback methods that start up an activity and a sequence of callback methods that tear down an activity"\n"
        "\n"
Four essential states:"\n"
Active:"\n"
When an Activity is at the top of the stack it is the visible, focused, foreground Activity that is receiving user input."\n"
When another Activity becomes active, this one will be paused."\n"
        "\n"
Paused:"\n"
If an Activity is visible but does not have focus; at this point its paused."\n"
When paused, an Activity is treated as if it were active; however, it doesnt receive user input events."\n"
In extreme cases Android will kill a paused Activity to recover resources for the active Activity."\n"
When an Activity becomes totally obscured, it is stopped."\n"
It is important to save all UI state and persist all data when an Activity is paused."\n"
Stopped:"\n"
When an Activity isnt visible, it stops."\n"
A stopped Activitiy is a candidate for termination when the system requires memory elsewhere"\n"
It is important to save all UI state and persist all data when an Activity is stopped."\n"
        "\n"
Inactive:"\n"
Inactive Activities have been removed from the Activity stack and need to be restarted before they can be displayed and used.</string>
    <string name="ins_frag">A Fragment is a piece of an activity which enable more modular activity design."\n"
It will not be wrong if we say, a fragment is a kind of sub-activity."\n"
Following are important points about fragment:"\n"
A fragment has its own layout and its own behaviour with its own life cycle callbacks."\n"
You can add or remove fragments in an activity while the activity is running."\n"
You can combine multiple fragments in a single activity to build a multi-pane UI."\n"
A fragment can be used in multiple activities."\n"
Basically fragments are divided as three stages as shown below."\n"
    "\n"
Single frame fragments:"\n"
    Single frame fragments are using for hand hold devices like mobiles, here we can show only one fragment as a view."\n"
"\n"
List fragments:"\n"
    fragments having special list view is called as list fragment."\n"
"\n"
Fragments transaction:"\n"
    Using with fragment transaction. we can move one fragment to another fragment.</string>
    <string name="inside_textview1">
        "\n"
        LinearLayout"\n"
            xmlns:android="http://schemas.android.com/apk/res/android""\n"
            android:layout_width="match_parent""\n"
            android:layout_height="match_parent"/>"\n"
        "\n"
    TextView "\n"
        android:id="@+id/text_view_id""\n"
        android:layout_height="wrap_content""\n"
        android:layout_width="wrap_content""\n"
        android:text="@string/hello" />"\n"
 </string>
    <string name="inside_textview2">
        public class MainActivity extends Activity"\n"
        {"\n"
    protected void onCreate(Bundle savedInstanceState)"\n"
        {"\n"
         super.onCreate(savedInstanceState);"\n"
         setContentView(R.layout.activity_main);"\n"
         final TextView helloTextView = (TextView) findViewById(R.id.text_view_id);"\n"
         helloTextView.setText(R.string.user_greeting);"\n"
     }"\n"
 }
    </string>
    <string name="inside_button1">
        Button"\n"
            android:id="@+id/button_id""\n"
            android:layout_height="wrap_content""\n"
            android:layout_width="wrap_content""\n"
            android:text="@string/self_destruct" />
    </string>
    <string name="inside_button2">
        public class MyActivity extends Activity "\n"
        {"\n"
     protected void onCreate(Bundle savedInstanceState)"\n"
        {"\n"
         super.onCreate(savedInstanceState);"\n"
         setContentView(R.layout.content_layout_id);"\n"
         final Button button = findViewById(R.id.button_id);"\n"
         button.setOnClickListener(new View.OnClickListener()"\n"
        {"\n"
             public void onClick(View v)"\n"
        {"\n"
                 // Code here executes on main thread after user presses button"\n"
             }"\n"
         });"\n"
     }"\n"
 }
    </string>
    <string name="inside_radioButton1">
        xml version="1.0" encoding="utf-8"?"\n"
        RadioGroup xmlns:android="http://schemas.android.com/apk/res/android""\n"
            android:layout_width="fill_parent""\n"
            android:layout_height="wrap_content""\n"
            android:orientation="vertical">"\n"

    RadioButton android:id="@+id/radio_pirates"\n""
        android:layout_width="wrap_content""\n"
        android:layout_height="wrap_content""\n"
        android:text="@string/pirates""\n"
        android:onClick="onRadioButtonClicked"/>"\n"
    RadioButton android:id="@+id/radio_ninjas""\n"
        android:layout_width="wrap_content""\n"
        android:layout_height="wrap_content""\n"
        android:text="@string/ninjas""\n"
        android:onClick="onRadioButtonClicked"/>"\n"
    </string>
    <string name="inside_radioButton2">
        public void onRadioButtonClicked(View view)"\n"
        {"\n"
    // Is the button now checked?"\n"
    boolean checked = ((RadioButton) view).isChecked();"\n"
    // Check which radio button was clicked"\n"
    switch(view.getId())"\n"
        {"\n"
        case R.id.radio_pirates:"\n"
            if (checked)"\n"
                // Pirates are the best"\n"
            break;"\n"
        case R.id.radio_ninjas:"\n"
            if (checked)"\n"
                // Ninjas rule"\n"
            break;"\n"
    }"\n"
}
    </string>
    <string name="inside_checkbox1">

        LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" "\n"
            android:orientation="vertical""\n"
            android:layout_width="fill_parent""\n"
            android:layout_height="fill_parent"/>"\n"
    CheckBox android:id="@+id/checkbox_meat""\n"
        android:layout_width="wrap_content""\n"
        android:layout_height="wrap_content""\n"
        android:text="@string/meat""\n"
        android:onClick="onCheckboxClicked"/>"\n"
    CheckBox android:id="@+id/checkbox_cheese""\n"
        android:layout_width="wrap_content""\n"
        android:layout_height="wrap_content""\n"
        android:text="@string/cheese""\n"
        android:onClick="onCheckboxClicked"/>"\n"
    </string>
    <string name="inside_checkbox2">
        public void onCheckboxClicked(View view)"\n"
        {"\n"
    // Is the view now checked?"\n"
    boolean checked = ((CheckBox) view).isChecked();"\n"
    // Check which checkbox was clicked"\n"
    switch(view.getId()) "\n"
        {"\n"
        case R.id.checkbox_meat:"\n"
            if (checked)"\n"
                // Put some meat on the sandwich"\n"
            else"\n"
                // Remove the meat"\n"
            break;"\n"
        case R.id.checkbox_cheese:"\n"
            if (checked)"\n"
                // Cheese me"\n"
            else"\n"
                // I am lactose intolerant"\n"
            break;"\n"
        // TODO: Veggie sandwich"\n"
    }"\n"
}
    </string>
    <string name="inside_rating1">
        RelativeLayout xmlns:androclass="http://schemas.android.com/apk/res/android""\n"
            xmlns:tools="http://schemas.android.com/tools""\n"
            android:layout_width="match_parent""\n"
            android:layout_height="match_parent""\n"
            tools:context=".MainActivity" >  "\n"
  "\n"
    RatingBar"\n"
        android:id="@+id/ratingBar1""\n"
        android:layout_width="wrap_content""\n"
        android:layout_height="wrap_content""\n"
        android:layout_alignParentTop="true""\n"
        android:layout_centerHorizontal="true""\n"
        android:layout_marginTop="44dp" />"\n"
  "\n"
    Button"\n"
        android:id="@+id/button1""\n"
        android:layout_width="wrap_content""\n"
        android:layout_height="wrap_content""\n"
        android:layout_alignLeft="@+id/ratingBar1""\n"
        android:layout_below="@+id/ratingBar1""\n"
        android:layout_marginLeft="92dp""\n"
        android:layout_marginTop="66dp""\n"
        android:text="submit" />"\n"
/RelativeLayout>
    </string>
    <string name="inside_rating2">
        public class MainActivity extends Activity"\n"
        {"\n"
    RatingBar ratingbar1;"\n"
    Button button;"\n"
    @Override"\n"
    protected void onCreate(Bundle savedInstanceState)"\n"
        {"\n"
        super.onCreate(savedInstanceState);"\n"
        setContentView(R.layout.activity_main);"\n"
        addListenerOnButtonClick();"\n"
    }"\n"
  "\n"
    public void addListenerOnButtonClick()"\n"
        {"\n"
        ratingbar1=(RatingBar)findViewById(R.id.ratingBar1);"\n"
        button=(Button)findViewById(R.id.button1);"\n"
        //Performing action on Button Click"\n"
        button.setOnClickListener(new OnClickListener()"\n"
        {"\n"
        @Override"\n"
            public void onClick(View arg0)"\n"
        {"\n"
                //Getting the rating and displaying it on the toast"\n"
                String rating=String.valueOf(ratingbar1.getRating());"\n"
                Toast.makeText(getApplicationContext(), rating, Toast.LENGTH_LONG).show();"\n"
            }"\n"
        });"\n"
    }"\n"
    @Override"\n"
    public boolean onCreateOptionsMenu(Menu menu)"\n"
        {"\n"
        // Inflate the menu; this adds items to the action bar if it is present."\n"
        getMenuInflater().inflate(R.menu.activity_main, menu);"\n"
        return true;"\n"
    }"\n"
}
    </string>
    <string name="ins_menu">
        Menus are a common user interface component in many types of applications."\n"
        To provide a familiar and consistent user experience, you should use the Menu APIs to present user actions and other options in your activities."\n"
        Beginning with Android 3.0 (API level 11), Android-powered devices are no longer required to provide a dedicated Menu button. "\n"
        With this change, Android apps should migrate away from a dependence on the traditional 6-item menu panel and instead provide an app bar to present common user actions."\n"
        Although the design and user experience for some menu items have changed, the semantics to define a set of actions and options is still based on the Menu APIs."\n"
        This guide shows how to create the three fundamental types of menus or action presentations on all versions of Android:"\n"

        <b>TYPES:</b>"\n"

         Options menu and app bar:"\n"
         The options menu is the primary collection of menu items for an activity."\n"
         Its where you should place actions that have a global impact on the app, such as "Search," "Compose email," and "Settings.""\n"
         "\n"
         Context menu and contextual action mode:"\n"
         A context menu is a floating menu that appears when the user performs a long-click on an element."\n"
         It provides actions that affect the selected content or context frame."\n"
         The contextual action mode displays action items that affect the selected content in a bar at the top of the screen and allows the user to select multiple items."\n"
         "\n"
         Popup menu:"\n"
         A popup menu displays a list of items in a vertical list thats anchored to the view that invoked the menu."\n"
         Its good for providing an overflow of actions that relate to specific content or to provide options for a second part of a command. Actions in a popup menu should not directly affect the corresponding contentâ€”thats what contextual actions are for."\n"
         Rather, the popup menu is for extended actions that relate to regions of content in your activity.
    </string>

</resources>
